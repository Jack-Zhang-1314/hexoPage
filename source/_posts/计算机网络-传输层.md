---
title: 计算机网络-传输层
date: 2021-11-04 19:41:55
author: Jack-zhang
categories: config
tags:
   - config
   - TCP
summary: 计算机网络
---

## 关于计算机网络的体系结构

 <table>
    <tr>
        <th>OSI的七层协议</th><th>四层协议</th><th>五层协议</th>
    </tr>
    <tr>
        <td>应用层</td><td rowspan="3">应用层(各种应用层协议TELNENT,FTP,SMTP等)</td><td rowspan="3">应用层</td>
    </tr>
    <tr>
        <td>表示层</td>
    </tr>
    <tr>
        <td>会话层</td>
    </tr>
    <tr>
        <td>传输层(TCP/UDP)</td><td>传输层(TCP/UDP)</td><td>传输层(TCP/UDP)</td>
    </tr>
    <tr>
        <td>网络层IP</td><td>网络层IP</td><td>网络层IP</td>
    </tr>
    <tr>
        <td>数据链路层</td><td rowspan="2">数据链路层</td><td>数据链路层</td>
    </tr>
    <tr>
        <td>物理层</td><td>物理层</td>
    </tr>
</table>

* 应用层协议:域名系统:**DNS**,支持万维网应用:**HTTP**,支持电子邮件:**SMTP**...我们把应用层交互的数据单元称为**报文**
* 传输层:负责两台主机中进程之间的通信提供的数据传输服务
  * TCP(传输控制协议):<span style="color:red">提供面向连接的,可靠的数据传输服务</span>,其数据传输的单位是**报文段**
  * UDP(用户数据报协议):<span style="color:red">提供无连接的,尽最大努力的数据传输服务(不保证数据传输的可靠性)</span>,其数据传输的单位是**用户数据段**
* 网络层:负责为分组交换网上的不同主机提供通信服务
  * 互联网的网络层协议是**无连接的网际协议IP**和多种路由选择协议.

## 传输层

1. 用户数据报协议(UDP):不需要先建立连接.不提供可靠交付,**但在有些情况下是最有效的**
2. 传输控制协议(TCP):提供面向连接的服务.

> 举例:使用UDP和TCP协议的某些应用

应用 | 应用层协议 | 运输层协议
---|-------|------
名字转换 | DNS(域名系统) | UDP
文件传送 | TFTP(简单文件传送协议) | UDP
IP地址配置 | DHCP(动态主机配置协议) | UDP
网络管理 | SNMP(简单网络管理协议) | UDP
电子邮件 | SMTP(简单邮件传送协议) | TCP
远程终端协议 | TELNET(远程终端协议) | TCP
万维网 | HTTP(超文本传输协议) | TCP
文件传输 | FTP(文件传输协议) | TCP

> 运输层的端口:对于两个计算机相互通信,不仅必须知道对方的IP地址(找到对方的计算机),而且要知道对方的端口号(找到对方计算机中的应用进程)

* 服务器端使用的端口号
  * 熟知端口号或系统端口号,数值:0~1023
  * 登记端口号:数值1024~49151.这类端口必须在IANA按照规定的手续登记,以防止重复
  
 | 应用程序 | FTP | HTTP | DNS | HTTPS | ...
 |------|-----|------|-----|-------|----
 | 熟知端口号 | 21 | 80 | 53 | 443 | ...

### UDP

1. `源端口`:源端口号.在需要对方回信时选用.不需要课全用0
2. `目的端口`:目的端口.在终点交付报文时必须使用
3. `长度`:UDP用户数据报的长度.其最小值是8(仅有首部)
4. `检验和`:检测UDP用户数据报在传输中是否有错.有错就丢弃

![UDP报文头部字段](UDP报文头部字段.png)

* UDP传输协议的主要特点
  1. UDP是无连接的,发送数据之前是不需要建立连接
  2. UDP使用尽最大努力交付,不保证可靠交付
  3. 面向报文.即应用层对UDP交付的报文,不管多长,照样发送,即一次发送一个报文
  4. 没有拥塞控制.如(ip电话,实时视屏会议等)要求源主机以恒定的速率发送数据,并且允许在网路拥堵时丢失一些数据
  5. UDP支持一对一,一对多,多对一,多对多的交互通信
  6. UDP首部开销小,只有8个字节,比TCP的20个字节的首部要短

### TCP

1. `面向连接`。所谓的连接，指的是客户端和服务器的连接，在双方互相通信之前，TCP 需要三次握手建立连接，而 UDP 没有相应建立连接的过程。
2. `可靠性`。TCP 花了非常多的功夫保证连接的可靠，这个可靠性体现在哪些方面呢？一个是有状态，另一个是可控制。
   * TCP 会精准记录哪些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错。这是有状态。
   * 当意识到丢包了或者网络环境不佳，TCP 会根据具体情况调整自己的行为，控制自己的发送速度或者重发。这是可控制。相应的，UDP 就是无状态, 不可控的。
3. `面向字节流`。UDP 的数据传输是基于数据报的，这是因为仅仅只是继承了 IP 层的特性，而 TCP 为了维护状态，将一个个 IP 包变成了字节流。
4. 每一条TCP连接`只能有两个端点`,每一条TCP连接之间能是点对点的.
   * TCP两端都设有发送缓存和接收缓存,用来临时存放双向通信的数据
   * 发送数据:应用程序将数据传送给TCP缓存后,就可以做自己的事,tcp会在合适时候发送数据
   * 接收数据:TCP把收到的数据放入缓存,上层的应用进程在合适的时候读取缓存的数据
5. `提供双全工通信`.允许通信双方的应用进程在任何时候都能发送数据

### 报文头部字段介绍

![tcp报文头部字段](tcp报文头部字段.jpg)

* TCP的序号和确认号
  1. 32位序号seq:`Sequence number`的缩写是seq,TCP通信过程中某一个传输方向上的字节流的每一个字节的序号,通过这个来通过这个来发送的数据是有序的(序列号是一个长为 4 个字节，也就是 32 位的无符号整数)
  1. 32位确认号 ack:`Ackonwledge number`缩写ack,TCP对上一次seq序号做出的确认号,用来响应TCP的报文段,给收到的
* TCP的标志位
  > 每个TCP段都有一个目的,这是借助于TCP标志位选项来确定的,允许发送方或接收方指定哪些标志应该被使用,以便端被另一端正确处理

  1. SYN:简写为`S`,同步标志位,用于建立会话连接,同步序列号
  2. ACK:简写为`.`,确认标志位,对已接收的数据包进行确认
  3. FIN:简写为`F`,完成标志位,表示我已经没有数据要发送,即将关闭连接
  4. PSH:简写为`P`,推送标志位,表示该数据包被对方接收后应立即交给上层应用,而不在缓冲区排队
  5. RST:简写为`R`,紧急标志位,重置标志位,用于连接复位,拒绝错误和非法的数据包
  6. URG:简写为`U`,紧急标志位,表示数据包的紧急指针域有效,用来保证连接不被阻断,并督促中间设备尽快处理

> 参考:<https://sanyuan0704.top/blogs/net/tcp/005.html#%E5%BA%8F%E5%88%97%E5%8F%B7>

### TCP的三次握手

> 模拟三次握手:TCP 三次握手跟现实生活中的人与人打电话是很类似的

* 三次握手
* "你好，听到吗"
* "我听得到啊，你听得到吗?"
* "我能听到你，我在..."

![tcp三次握手](tcp三次握手.jpg)

> 第一次握手

1. 客户端将TCP报文标志位SYN位置为1,随机产生一个序号值seq=x,并保存在TCP首部的ACK序列号(seq)例,指明客户端打算连接的服务器的端口,并将该数据包发送给服务器端
2. 发送完毕,客户端进入`SYN_SENT`状态,等待服务器端确认

> 第二次握手

1. 服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将TCP报文标志位SYN和ACK都置为1，ack=x+1，随机产生一个序号值seq=y，并将该数据包发送给客户端以确认连接请求，
2. 服务器端进入`SYN_RCVD`状态

> 第三次握手

1. 客户端收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并将该数据包发送给服务器端，服务器端检查ack是否为y+1，ACK是否为1，
2. 如果正确则连接建立成功，客户端和服务器端进入`ESTABLISHED`状态，
3. 完成三次握手，随后客户端与服务器端之间可以开始传输数据了。
4. 第三次握手时可以携带数据

* SYN 是需要消耗一个序列号的，下次发送对应的ack(序列号)要加1，为什么呢？只需要记住一个规则:
  > 凡是需要对端确认的，一定消耗TCP报文的序列号。

> 两次握手建立连接的问题:**服务端无法确认客户端的接收能力**

* 第一次握手:服务端确认客户端有发送数据的能力
* 第二次握手:客户端确认服务端有接收和发送数据的能力
* 第三次握手:服务端端确认客户端有接收数据的能力

>参考:<https://sanyuan0704.top/blogs/net/tcp/002.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1>

### TCP的四次挥手

>四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开

* TCP连接是全双工的，因此，每个方向都必须要单独进行关闭
* 这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN
* 首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭

![tcp四次挥手](tcp四次挥手.jpg)

> 第一次挥手

* 客户端发送挥手请求,向服务端发送的标志位是FIN报文段,设置序列号**seq=p**
* 客户端端进入`FIN_WAIT_1`状态，这表示客户端端没有数据要发送给服务端
* 服务端接收后向客户端确认，变成了`CLOSED-WAIT`状态

>第二次挥手

* 客户端收到了服务端发送的FIN报文段，向服务端返回一个标志位是`ACK`的报文段，**ack设为seq加1(ack=p+1)**
* 客户端进入`FIN_WAIT_2`状态，客户端告诉服务端，我确认并同意你的关闭请求

>第三次挥手

* 客户端向服务端发送标志位是FIN的报文段，请求关闭连接，
* 设服务端的**seq=q**,**ack=p+1**同时服务端进入`LAST_ACK`状态

>第四次挥手

* 客户端收到服务端发送的FIN报文段，向服务端发送标志位是ACK的报文段，然后客户端进入`TIME_WAIT`状态。
* 服务端收到客户端的ACK报文段以后，就关闭连接。此时，客户端等待2MSL的时间后依然没有收到回复，则证明服务端已正常关闭，
* 那客户端也可以关闭连接了

> 等待2MSL的意义

* 如果客户端直接跑路，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，最保险的做法是等服务器发来的数据包都死翘翘再启动新的应用。
* 使用2个MSL
  * 1个MSL确保四次挥手中主动关闭方最后的`ACK`报文最终能达到对端
  * 1个MSL确保对端没有收到ACK重传的`FIN`报文可以到达

>参考:<https://sanyuan0704.top/blogs/net/tcp/003.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%89%E6%AC%A1>
