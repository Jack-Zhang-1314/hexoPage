---
title: http
date: 2021-11-08 13:51:42
author: Jack-zhang
categories: config
tags:
   - config
   - HTTP
summary: 计算机网络
---

## 应用层协议

* 应用进程交换的报文类型,如**请求报文**和**响应报文**
* 各种报文类型的语法,如报文中各个字段极其响应描述
* 字段的语义,即包含在字段中的各个字段极其详细描述
* 进程何时,如何发送报文,以及对报文进行响应的规则

>应用层协议只是网络应用的一部分.应用层的许多协议都是基于客户服务其方式

### DNS

> DNS-从域名解析出ip地址

* 把待解析的域名放在DNS请求报文中,以UDP用户数据报方式发给本地域名服务器.
  * 本地域名服务器找到域名后,把对应的ip地址放在回答报文中返回
  * 应用进程获得目的主机的ip地址后即可进行通信
* 若本地域名服务器不能回答该请求
  * 则此服务器端暂时成为DNS的另一个客户,并向其它域名发送查询请求

> DNS高效率:DNS的大部分名字都在本地进行解析,仅少量的解析需要在互联网上通信.

* `mail.cctv.com`
  * `mail`是三级域名
  * `cctv`是二级域名
  * `com`是一级域名

### 万维网(www)

>* 万维网是一个大规模的,联机式的信息储藏所,简称Web
>* 万维网是一个分布式的超媒体系统,他是超文本系统的扩充

* 万维网以客户服务器的方式工作
  * 客户程序向服务程序发出请求,服务程序向客户程序送回客户所要的万维网文档
    * `超文本文档`仅包含文本信息
    * `超媒体文档`还包含其它表示方式的信息,如图像,声音,视频等
  * 如何标志分布在整个互联网上的万维网文档
    * 统一资源定位符**URI**
  * 用什么样的协议实现万维网上的各种链接
    * 超文本传输协议(`HTTP`)
  * 如何使用户能方便找到用户信息
    * 使用**超文本标记语言HTML**

### URI

>URI:统一资源标识符,URI包含URL和URN,由于URL过于普及,默认作为URI

* URL:统一资源定位符
* URN:统一资源名称
* 例:例如一个文件`a.html`可以用`https://www.baidu.com/a.html`  
  * 也可以用`URN`:`urn:a:1535-3613`

* ![URI](URI.png)

名称 | 描述
---|---
scheme | 协议名,比如http, https
user:passwd@ | 登录主机时的用户信息,不过很不安全,不推荐使用,也不常用
host:port | 主机名(**域名或者IP地址**)和端口
path | 请求路径,标记资源所在位置
query | 查询参数,为`key=val`这种形式,多个键值对之间用&隔开
fragment | URI 所定位的资源内的一个锚点,浏览器可以根据这个锚点跳转到对应的位置

>参考:<https://sanyuan0704.top/blogs/net/http/003.html#uri-%E7%9A%84%E7%BB%93%E6%9E%84>

* `https`就是`scheme`
* `sanyuan0704.top`就是`host:port`,(http,https)默认端口是80,443可以省略不写
* `/blogs/net/http/003.html`就是`path`
* `uri-%E7%9A%84%E7%BB%93%E6%9E%84`就是`fragment`

> 关于URI编码

* URI只能使用ASCII, ASCII之外的字符是不支持显示的,而且还有一部分符号是界定符,如果不加以处理就会导致解析出错.
  * URI引入了编码机制,将所有非ASCII码字符和界定符转为十六进制字节值,然后在前面加个%.
  * 空格被转义成了%20,`的结构`就被转译成`%E7%9A%84%E7%BB%93%E6%9E%84`

### HTTP的操作过程(特点)

> 每个万维网的网点都有一个服务进程,他不断的监听`TCP`的端口`80`,一遍发现浏览器向它发出连接建立请求

* **HTTP的协议本身是无连接的**
  1. HTTP使用了面向连接的TCP作为传输层协议,保证数据的可靠传输
  2. 虽然HTTP使用TCP连接,但通信的双方在交换HTTP报文之前不需要先建立HTTP建立

* **HTTP协议是无状态的**  
  1. 协议对于事务处理没有记忆能力
  2. 同一个客户第二次访问同一个服务器上的页面时,服务器响应与第一次访问时相同
  3. 每次的请求都是独立的,它的执行情况和结果与前面的请求和之后的请求是无直接关系的,它不会受前面的请求应答情况直接影响,也不会直接影响后面的请求应答情况(`无直接联系`)
  4. 服务器中没有保存客户端的状态,客户端必须每次带上自己的状态去请求服务器

* **明文传输**
  1. 即协议里的报文(主要指头部)不使用二进制数据.而是文本形式
  2. 方便调试的同时,HTTP的报文信息暴露给了外界,给攻击者也提供了便利
  
* **队头阻塞问题**
  1. http开启长连接时,使用同一个TCP连接
  2. 同一时刻只能处理同一个请求,当前请求时间过长,其它请求只能处于阻塞状态

* **HTTP协议首先要和服务器建立TCP连接**
  1. 建立TCP连接三次握手的前面两部分完成后(即经过了一个RTT时间后)
  2. 万维网客户就把HTTP请求报文,**作为建立TCP连接的第三个报文**的数据发送给万维网数据
  3. 服务器收到HTTP请求报文后,就把所请求的文档作文响应报文返回给客户

![请求一个文档所需的时间](请求一个文档所需的时间.png)

* 该文档的传输时间(与文档大小成正比)加上两倍往返时间(RTT)
  * 一个RTT用于连接TCP连接
  * 另一个RTT用于请求和接收万维网文档
  * TCP建立的第三个报文段中的数据就是客户端对万维网的请求报文

### 串行连接、持久连接、管道化持久连接、http/2.0多路复用简介

* **串行连接**:HTTP有`无连接的特性,即每次连接只能处理一个请求,收到响应后立即断开连接`.`HTTP/1.0`版本称为**串行连接或短连接、短轮询**中每次HTTP通信后都要断开TCP连接,所以每个新的HTTP请求都需要建立一个新的连接.但在现在网站动则几十条HTTP请求的情况下,很容易达到浏览器请求上限,并且每次请求都建立新的tcp连接(每次都有三次握手四次挥别)<span style="color:red">极大的增加了通信开销</span>.

* **持久连接**:为解决这个问题,有人提出了`持久连接(也叫长连接、长轮询)`.一定时间内,同一域名下的HTTP请求,只要两端都没有提出断开连接,则**持久保持TCP连接状态**,其他请求可以`复用这个连接通道`.`HTTP/1.1` 实现并<u style="color:red">默认了所有连接都是持久连接</u>,这样客户端发起多个HTTP请求时就减少了TCP握手造成的网络资源和通信时间的浪费.<span style="color:red">但是持久连接采用阻塞模式,下次请求必须等到上次响应返回后才能发起,如果上次的请求还没返回响应内容,下次请求就只能等着</span>(就是常说的线头阻塞)

* **管道化持久连接**:管道化则可以不用等待响应返回而发送下个请求并按顺序返回响应,现代浏览器并未默认开启管道化.

* **HTTP/2.0多路复用**： 每个HTTP请求都有一个**序列标识符**,这样浏览器可以并发多个请求,服务器接收到数据后,再根据序列标识符重新排序成不同的请求报文,而不会导致数据错乱.同样,服务端也可以并发返回多个响应给浏览器,浏览器收到后根据序列标识重新排序并归入各自的请求的响应报文.<span style="color:red">并且同一个域名下的所有请求都复用同一个TCP连接,极大增加了服务器处理并发的上限</span>.

* **WebSocket**： WebSocket是HTML5提出的一种客户端和服务端通讯的全双工协议,由客户端发起请求,<u>建立连接之后不仅客户端可以主动向服务端发送请求,服务端可以主动向客户端推送信息.</u>

![连接](连接.jpg)

>参考:<https://juejin.cn/post/6844903844216832007#heading-3>

### 代理服务器

* 代理服务器相当于中间人
  * 它既可以当作客户端发送请求,也可以当作服务端响应请求

![代理服务器](代理服务器.png)

### HTTP2.0

> HTTP/2而言性能的提升主要两点:

* 头部压缩
* 多路复用

#### 头部压缩

* 关于请求体压缩的方式
  * 使用`Content-Encoding`可以指定头部字段来指定请求体响应的压缩编码过程
* HTTP/2针对头部字段,也采用对应的压缩算法--**HPACK**,对请求头进行压缩

> HPACK算法专门为HTTP/2服务

* 首先是在服务器和客户端之间建立哈希表,将用到的字段存放在这张表中,那么在传输的时候对于之前出现过的值,只需要把索引(比如0,1,2,...)传给对方即可,对方拿到索引查表就行了.

![头部压缩](头部压缩.png)

>HTTP/2 当中废除了起始行的概念,将起始行中的请求方法、URI、状态码转换成了头字段,不过这些字段都有一个":"前缀,用来和其它请求头区分开.

* 参考:<https://sanyuan0704.top/blogs/net/http/017.html#%E5%A4%B4%E9%83%A8%E5%8E%8B%E7%BC%A9>

#### 多路复用

>在HTTP/2中,有两个非常重要的概念,分别是帧`frame`和流`stream`,理解这两个概念是理解下面多路复用的前提.**帧代表数据传输的最小的单位**,每个帧都有序列标识表明该帧属于哪个流,**流也就是多个帧组成的数据流**,每个流表示一个请求.

* http队头阻塞:在同一个 TCP 长连接中，前面的请求没有得到响应，后面的请求就会被阻塞
  * 解决1:使用**并发连接**和**域名分片**的方式来解决,<span style="color:red">只是增加了 TCP 连接,并没有解决HTTP层面的问题</span>

* HTTP/2 便从 HTTP 协议本身解决了队头阻塞问题。
* 注意，这里并不是指的`TCP队头阻塞`，而是`HTTP队头阻塞`，两者并不是一回事。<u>TCP的队头阻塞是在数据包层面，单位是数据包</u>，前一个报文没有收到便不会将后面收到的报文上传给 HTTP，而HTTP 的队头阻塞是在 HTTP **请求-响应层面**，前一个请求没处理完，后面的请求就要阻塞住。两者所在的层次不一样。

> 解决对头阻塞的问题(二进制分帧)

* 首先HTTP/2之前使用的明文传输,不方便计算机的解析.列如回车换行是内容还是分割符,所以HTTP/2就把报文全部转换为二进制
  * 将`Headers + Body`的报文格式如今被拆分成了一个个二进制的帧
  * 用Headers帧存放头部字段，Data帧存放请求体数据
  * 分帧之后不再是一个个完整的HTTP请求报文,而是一堆乱序的二进制帧
  * 二进制帧没有先后关系,也不存在队头阻塞

>关于通信双方给对方互相发送的二进制帧的双向传输的序列就是**流(stream)**.HTTP/2 

* **多路复用**:用**流**来在一个 TCP 连接上来进行多个数据帧的通信

> 参考:<https://sanyuan0704.top/blogs/net/http/017.html#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E5%B8%A7>

### http报文属性

* <https://zyjcould.ltd/2021/09/20/nodejs/#toc-heading-9>
